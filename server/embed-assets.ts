#!/usr/bin/env bun
/**
 * Embeds client build assets into a TypeScript module for single-binary distribution.
 * Run this after `npm run build` and before `bun build --compile`.
 */

import { readdir, readFile, writeFile, stat } from 'fs/promises'
import { join, dirname } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const DIST_DIR = join(__dirname, '../dist')
const OUTPUT_FILE = join(__dirname, 'embedded-assets.ts')

interface Asset {
  content: string
  contentType: string
}

function getContentType(filename: string): string {
  if (filename.endsWith('.html')) return 'text/html; charset=utf-8'
  if (filename.endsWith('.js')) return 'application/javascript; charset=utf-8'
  if (filename.endsWith('.css')) return 'text/css; charset=utf-8'
  if (filename.endsWith('.json')) return 'application/json; charset=utf-8'
  if (filename.endsWith('.svg')) return 'image/svg+xml'
  if (filename.endsWith('.png')) return 'image/png'
  if (filename.endsWith('.ico')) return 'image/x-icon'
  if (filename.endsWith('.woff2')) return 'font/woff2'
  if (filename.endsWith('.woff')) return 'font/woff'
  if (filename.endsWith('.map')) return 'application/json'
  return 'application/octet-stream'
}

async function collectFiles(dir: string, basePath: string = ''): Promise<Map<string, Asset>> {
  const assets = new Map<string, Asset>()
  const entries = await readdir(dir, { withFileTypes: true })

  for (const entry of entries) {
    const fullPath = join(dir, entry.name)
    const relativePath = basePath ? `${basePath}/${entry.name}` : entry.name

    if (entry.isDirectory()) {
      const subAssets = await collectFiles(fullPath, relativePath)
      for (const [key, value] of subAssets) {
        assets.set(key, value)
      }
    } else {
      const content = await readFile(fullPath)
      const contentType = getContentType(entry.name)

      // Store as base64 for binary files, utf-8 for text
      const isText = contentType.includes('text') ||
                     contentType.includes('javascript') ||
                     contentType.includes('json') ||
                     contentType.includes('svg')

      assets.set('/' + relativePath, {
        content: isText ? content.toString('utf-8') : content.toString('base64'),
        contentType: isText ? contentType : contentType + ';base64',
      })
    }
  }

  return assets
}

async function main() {
  // Check if dist exists
  try {
    await stat(DIST_DIR)
  } catch {
    console.error('Error: dist/ directory not found. Run `npm run build` first.')
    process.exit(1)
  }

  console.log('Collecting assets from dist/...')
  const assets = await collectFiles(DIST_DIR)

  console.log(`Found ${assets.size} files:`)
  for (const path of assets.keys()) {
    console.log(`  ${path}`)
  }

  // Generate TypeScript module
  const entries: string[] = []
  for (const [path, asset] of assets) {
    const escaped = asset.content
      .replace(/\\/g, '\\\\')
      .replace(/`/g, '\\`')
      .replace(/\$/g, '\\$')
    entries.push(`  '${path}': { content: \`${escaped}\`, contentType: '${asset.contentType}' }`)
  }

  const output = `// Auto-generated by embed-assets.ts - DO NOT EDIT
// Run \`bun server/embed-assets.ts\` to regenerate

export interface EmbeddedAsset {
  content: string
  contentType: string
}

export const embeddedAssets: Record<string, EmbeddedAsset> = {
${entries.join(',\n')}
}

export function getAsset(path: string): EmbeddedAsset | undefined {
  // Normalize path
  if (!path.startsWith('/')) path = '/' + path
  return embeddedAssets[path]
}

export function getIndexHtml(): EmbeddedAsset | undefined {
  return embeddedAssets['/index.html']
}
`

  await writeFile(OUTPUT_FILE, output)
  console.log(`\nGenerated ${OUTPUT_FILE}`)
}

main()
